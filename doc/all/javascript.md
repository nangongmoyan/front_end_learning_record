# JS 面试题

### 1.介绍 JS you 哪些内置对象

- **数据封装类对象：** Object、Array、Boolean、Number、String
- **其他对象：** Function、Arguments、Math、Date、RegExp、Error
- **ES6 新增对象：** Symbol（标识唯一性的 ID）、Map、Set、Promises、Proxy、Reflect

### 2.如何最小化重绘(repaint)和回流(reflow)

- 需要对元素进行复杂的操作时，可以先隐藏（display:"none"），操作完成后再显示
- 需要创建多个 DOM 节点，使用 DocumentFragment 创建完成后一次性的加入 document
- 缓存 Layout 属性值，如 var left = elem.offsetLeft，这样多次使用 left 只产生一次回流
- 尽量避免使用 table 布局（table 元素一旦触发回来就会导致 table 里面所有的其他元素回流）

### 3.JavaScript 作用域链

- 全局函数无法查看局部函数的内部细节，局部函数可以查看其上层的函数细节，直至全局细节
- 如果当前作用域没有找到属性或方法，会向上层作用域[Scoped]查找，直至全局函数，这种形式就是作用域链

### 4. 跨域和同源策略

所谓的同源其实是浏览器的一种机制，只允许在同源（同协议、同域名、同端口号）的情况下才能进行数据交互。但是我们在开发项目的过程中，往往一个项目的接口不止一个域，所以往往需要做跨域的处理，通常的跨域方式有这么几种：

- **JSONP：** 主要依赖于 script 不受同源策略影响，src 指向某一个接口的地址，同步需要传递 callback 回调函数的名字，这样子接口调用成功后，本地创建的全局回调函数就会执行，并且接受到数据。不使用 img 标签的原因是 img 标签无法执行 js 语句
- **CORS：** 依赖服务端对前端的请求头信息进行放行，不做限制

```
Access-Control-Allow-Origin:*
```

- **代理访问：** 前端访问不存在的跨域问题的代理服务器，代理服务器再去访问目标服务器（服务器直接没有跨域限制）

### 5.闭包

闭包是 JS 的一种特性，往往用于解决一些特定的问题，当 A 函数中返回了 B 函数，并且返回的 B 函数中有使用到 A 函数中的局部变量（包含参数）就会形成一个特性的形态，就叫做闭包

此时，理论上来说 A 函数执行完后，生成了 B 函数后，应该被垃圾回收机制回收，但是因为生成的 B 函数还在使用 A 函数中的局部变量，就会导致 A 函数没有及时回收，导致内存泄漏

**像函数防抖、截流也使用到了闭包**

### 6.cookie 和 session

cookie 和 session 都是为 HTTP 请求挂载状态的，也就说在前后端交互的过程中，往往需要利用 cookie 或者 session 来对客户端进行标记

**传统的 cookie 验证方式：**

- 客户端向服务端登录的时候，服务端直接通过响应头上 set-cookie 字段，为浏览器客户端注入 cookie，或者将对应的信息放置在响应内容中，客户端自行将其存储在 cookie 中
- 客户端在每次发送请求的时候就可以将 cookie 携带在请求头上进行数据的传递，服务端拿到此次请求头中的 cookie 进行验证
- 客户端自行设置 cookie 或者由服务端设置 cookie 的时候也去设置此 cookie 的过期时间，当 cookie 过期后相当于登录过期了

**session 验证方式：**

- 客户端向服务端登录的时候，服务端自行建立客户信息表，并且建立生命周期机制，服务端再将此信息通过 cookie 或者数据直接返回的形式，返回给客户端
- 客户端拿到验证信息后，可以选择存储在 cookie 或者 localStorage 中都可以
- 每次请求的时候携带验证信息（cookie 就自动写到，localStorage 需要取出携带）
- 服务端接收到请求后，判断该验证信息是否过期

**cookie 和 session 的本质都是利用 cookie 或者 localStorage 来进行数据交互，cookie 和 localStorage 又都有跨域的限制，cookie 通过 domain 可以实现一级域名下的二级域名之间可以互相访问，localStorage 则不能跨域**

### 线程和进程的区别

进程是资源分配的最小单元，线程是代码执行的最小单元

一个应用程序可能会开启多个进程，进程之间数据不共享，一个进程内部可以开启多个线程，线程之间的数据可以共享的，所以多线程的情况下，往往要考虑的是线程间执行顺序的问题

浏览器其实也可以通过 webWorkers 开启多线程

### 协商缓存和强缓存的区别

### http 和 https 区别以及哪个更安全

HTTP 明文传输，数据没有加密，安全性较差；HTPPS（HTTP+SSL/TSL），数据传输过程是加密的，安全性要好一些

使用 HTTPS 协议要经过 SSL 认证来申请 SSL 证书，认证拿到证书的过程一般都是收费的，所以成本略高

HTTP 的速度比 HTTPS 要更快一些，就是因为 HTTP 和服务器建立连接通过 TCP 的三次握手，客户端和服务端只需要交换 3 个包；HTTPS 在进行连接的时候除了要 TCP 的 3 个包，还要加上 SSL 握手的 9 个包，一个 12 个包

默认端口不同，HTTP 默认端口是 80，HTTPS 默认端口是 443

**HTTPS 认证是怎么认证的？**

客户端和服务端进行数据传输之前，先通过证书对双方进行身份验证：

- 客户端在发送 SSL 握手信息给服务端要求链接
- 服务端会将证书发送给客户端
- 客户端检查服务端证书，确认这个证书的签发机构是否值得信任，如果检查有问题，客户端会将是否继续通讯的决定权交给客户端，如果检查无误，或者用户选择继续，就表现客户端认可了服务端身份
- 服务端要求客户端发送证书，并且检查是否通过验证，失败就关闭链接，成功的话就得到客户端的公钥
  至此，服务端及客户端双方身份认证接收，双方都确保彼此身份可靠

**HTTPS 一定安全吗？**

不一定，HTTPS 往往无法阻止中间人攻击

A 和 B 进行数据交互的时候，可以采用加密的方式，加密分为对称和不对称两种

对称加密只要被破解出加密方式，就很容易泄漏信息

A 生成一个密钥 ka，B 生成一个密钥 kb；ka 用于解密 A 加密的数据，kb 用户解密 B 加密的数据，A 将 ka 传递给 B，B 将 kb 传递给 A，这样的话，A 再给 B 传递信息的时候，B 接受到之后用 ka 来进行解密。

HTTPS 进行密文传输的时候采用的不对称加密的方式。但是如果有中间人拦截请求后模仿 A 和 B 来与 B 和 A 进行通信的时候也会泄漏数据

### 前端攻击

##### CSRF(跨域请求伪造)

**完成一次 CSRF 攻击，受害者必须满足两个必要的条件：**

- 登录受信任的网站 A，并生成本地 cookie（如果用户没有登录网站 A，那么网站 B 在诱导的时候，请求网站 A 的 api 接口时，会提示你登录）
- 在不登出 A 网站的情况下，访问危险网站 B（其实是利用了网站 A 的漏洞）

**注意：** _cookie 保证了用户可以处以登录状态，但网站 B 其实拿不到 cookie_

**CSRF 的防范措施：**

- **Token 验证（用的最多）：** 服务器发送给客户端一个 token；客户端提交表单中带着这个 token；如果这个 token 不合法，那么服务器拒绝这个请求
- **隐藏令牌：** 把 token 隐藏在 http 的 head 头中
- **Referer 验证：** Referer 指的是页面的请求来源；意思只接收本站的请求，服务器才做响应，如果不是就拦截

##### XSS（）

原理：不需要你做任何登录认证，它会通过合法的操作（比如在 url 中输入、在评论框中输入），向你的页面注入脚本（可能是 js、html 代码块等）
结果：1.盗用 cookie；2.破坏页面的正常结构，插入广告等恶意内容；3.D-doss 攻击

**XSS 的防范措施：**

- **编码：** 对用户输入的数据进行 HTML Entity 编码
- **过滤：**
  --移除用户输入的和时间相关的属性。如 onerror 可以自动触发攻击，还有 onclick 等（过滤到一些不安全的内容）
  --移除用户输入的 Style 节点、Script 节点、Iframe 节点（尤其是 Script 节点，它可是支持跨域的，一定要移除）

##### CSRF 和 XSS 的区别

- **CSRF：** 是利用网站 A 本身的漏洞，去请求网站 A 的 api
- **XSS：**是向网站 A 注入 JS 代码，然后执行 JS 里的代码，篡改网站 A 的内容
